"""Add multiple names to artists

Revision ID: dc8fe9ef4e90
Revises: 06a2090ad210
Create Date: 2021-04-30 15:28:15.731087

"""
from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision = 'dc8fe9ef4e90'
down_revision = '06a2090ad210'
branch_labels = None
depends_on = None

# Table definitions
t_artist = sa.Table(
    'artist',
    sa.MetaData(),
    sa.Column('id', sa.Integer),
    sa.Column('name', sa.Unicode(length=255)),
)

def upgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    t_label = op.create_table(
        'label',
        sa.Column('id', sa.Integer(), nullable=False),
        sa.Column('name', sa.Unicode(length=255), nullable=False),
        sa.PrimaryKeyConstraint('id')
    )
    t_artist_names = op.create_table(
        'artist_names',
        sa.Column('label_id', sa.Integer(), nullable=False),
        sa.Column('artist_id', sa.Integer(), nullable=False),
        sa.ForeignKeyConstraint(['artist_id'], ['artist.id'], ),
        sa.ForeignKeyConstraint(['label_id'], ['label.id'], ),
        sa.PrimaryKeyConstraint('label_id', 'artist_id')
    )
    # ###

    connection = op.get_bind()
    # Select all existing names that need migrating.
    artist_results = connection.execute(sa.select([
        t_artist.c.id,
        t_artist.c.name,
        ])).fetchall()
    # Insert description records (unique only)
    seen_items = set()
    for artist_id, name in artist_results:
        if name in seen_items:
            continue
        connection.execute(t_label.insert().values(
            name=name,
            ))
        seen_items.add(name)
    label_results = connection.execute(sa.select([
        t_label.c.id,
        t_label.c.name,
        ])).fetchall()
    # Insert many-to-many records
    for artist_id, name in artist_results:
        for label_id, label_name in label_results:
            if name == label_name:
                connection.execute(t_artist_names.insert().values(
                    artist_id=artist_id,
                    label_id=label_id,
                    ))

    # ###
    with op.batch_alter_table('artist', schema=None) as batch_op:
        batch_op.drop_column('name')
    # ### end Alembic commands ###


def downgrade():
    # Table definitions
    t_label = sa.Table(
        'label',
        sa.MetaData(),
        sa.Column('id', sa.Integer()),
        sa.Column('name', sa.Unicode(length=255)),
    )
    t_artist_names = sa.Table(
        'artist_names',
        sa.MetaData(),
        sa.Column('label_id', sa.Integer()),
        sa.Column('artist_id', sa.Integer()),
    )

    # ### commands auto generated by Alembic - please adjust! ###
    with op.batch_alter_table('artist', schema=None) as batch_op:
        batch_op.add_column(sa.Column('name', sa.VARCHAR(length=255), nullable=True))

    connection = op.get_bind()
    label_results = connection.execute(sa.select([
        t_label.c.id,
        t_label.c.name,
        ])).fetchall()
    artist_name_results = connection.execute(sa.select([
        t_artist_names.c.artist_id,
        t_artist_names.c.label_id,
        ])).fetchall()
    # Update description column
    for artist_id, label_id in artist_name_results:
        name = next(filter(lambda x: x[0] == label_id, label_results), None)
        if name is None:
            continue
        connection.execute(t_artist.update().where(t_artist.c.id == artist_id).values(
            name=name[1],
            ))

    op.drop_table('artist_names')
    op.drop_table('label')
    # ### end Alembic commands ###
